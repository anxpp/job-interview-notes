# database

## 数据库理论

### 事务

    ACID：原子性、一致性、隔离性、持久性

- 原子性：事务不可分割，要嘛全部成功，要嘛全部失败
- 一致性：事务操作符合逻辑一致性
- 隔离性：事务间互不影响
- 持久性：事务提交后数据将持久化到存储系统

### 并发一致性问题

    持久性用于应对系统崩溃
    只要满足一致性，即可保证执行结果正确

要保证一致性，考虑情况：

- 无并发：只要满足原子性，即可满足一致性
- 有并发：同时需要满足隔离性才能保证一致性

实际问题：

- 丢失修改：事务t1的修改被t2覆盖
- 都脏数据：读到其他事务未提交的数据
- 不可重复读：事务中两次读取同一数据(集)，结果不同，本质也是脏读
- 幻读：事务中两次读取范围数据(比如count in range)结果不同，本质也是不可重复读

引起并发一致性问题的根本原因是破坏了事务的隔离性，通过加锁的方式解决

### 锁

#### 锁粒度

    锁粒度越细，并发程度越高，但是用于锁的操作会造成更多的开销

- 行级锁：并发程度高，系统开销大
- 表级锁：并发成都低，系统开销小

#### 读写锁

- 写锁，也叫互斥锁（X锁）
- 读锁，也叫共享锁（S锁）

X锁和S锁之间，只有S锁和S锁是兼容的，SX、XS，XX均不兼容

#### 意向锁

    考虑情况：如果t1对表的某一行加了X锁（行锁），事务t2要对表加x锁（表锁），这时需要做的操作：
    1、判断有没有其他表锁
    2、条件1通过，判断每一行是不是都被锁
    这种情况效率低下，于是引入意向锁。
    IX，IS意向锁都是表锁

- 事务在获取某数据行的S锁前，必须先获得IS或更强的锁
- 事务在获取某数据行的X锁前，必须先获得IX锁

### 三级封锁协议

    事务隔离基础理论

- 1、事务要修改数据a时必须加X锁，知道事务结束（解决丢失修改）
- 2、在（1）的基础上，事务读取数据a时，必须加S锁，读完施放（解决脏读）
- 3、在（2）的基础上，事务读取数据a时，必须加S锁，事务结束才能释放（解决不可重复读）

### 两段锁协议

    通常事务都是并发执行的，为了让事务可串行化调度（并发执行的结果和串行执行的结果一致），需要特定机制，也就是两段锁协议：加锁和解锁分为两个阶段
    事务开始时获取所有的锁，然后执行，再释放所有锁

- 1、加锁阶段：加锁不成功就等待（该阶段不能解锁），成功后执行
- 2、释放阶段：释放后进入封锁阶段，只能做解锁操作

### 隔离级别

    MySQl默认隔离级别可重复读
    Oracle默认隔离级别读已提交

- 读未提交：可以读取到其他事务未提交的数据
- 读已提交：只能读到其他事务提交的数据（解决脏读）
- 可重复读：保证在同一个事务中多次读取同一数据的结果一样（解决不可重复读）
- 可串行化：事务串行化执行，没有并发一致性问题（解决幻读）

### MVCC

    即多版本并发控制：主要目的是读数据免加锁，提高性能

#### 基础概念：版本号

- SYS_ID：系统版本号，每开始一个新事务，就递增
- TRX_ID：事务版本号，事务开始时的系统版本号

#### 快照

    快照是实现MVCC的基本思想
    写操作会创建最新的版本快照（针对数据行），读操作读取旧的版本快照

MVCC中，事务的修改操作（delete、insert、update）会为数据行新增一个版本快照

MVCC规定，只能读取已经提交的快照（无锁的情况下解决脏读和不可重复读）

- 快照读

```sql
select * from ?;
```

读取快照中的数据，不需要加锁

- 当前读

```sql
insert;
update;
delete;
```

 修改操作，需要加锁，能读到最新的数据

```sql
// S锁
select ... lock in share mode;
// X锁
select ... for update;
```

显示的加锁读，也是读最新快照

#### Undo日志

快照存储在undo日志中，通过回滚指针把数据行的所有快照连起来

#### ReadView 读视图

    读视图维护未提交的事务列表（TRX_IDs）以及该列表最大最小值（TRX_ID_MAX，TRX_ID_MIN）

进行select操作时，选取快照的方式：

- 当前TRX_ID < MIN：快照在所有事务开始之前生成的，可以使用
- 当前TRX_ID > MAX：在事务启动后生成的快照，不可使用
- MIN <= 当前TRX_ID <= MAX：
    - 1、隔离级别为读已提交时，如果当前TRX_ID在未提交事务列表中（即事务还未提交），不可使用，否则就可以使用
    - 2、隔离级别为可重复读：如果可以使用，那其他事务也可以使用，如果被其他事务修改了，那么该事务再次读取就会产生不可重复度，所以不能使用

如果快照不可用，就通过回滚指针在undo日志中找到下一个快照执行上面的判断

#### 间隙锁

    间隙锁锁的是索引，而且是按索引的间隙加锁
    间隙锁解决幻读

如果索引是1，4，7，9

```sql
select ... WHERE id between 5 and 8 for update;
```

上面的sql会锁住的间隙：(4,7),(7,9)，其他事务就不能插入6

## MySQL

    重点是InnoDB 和 B+树

### 存储引擎

- InnoDB：支持事务，支持行锁，综合性能优
- MyISAM：不支持事务，仅支持表锁，读性能优，崩溃顺坏率高，支持压缩表，崩溃恢复速度慢

优先使用InnoDB，如果读多场景，可以考虑主从中从库使用MyISAM。

### 索引

    重点B+树

- B+树：出度为M（值通常比较大）的多叉树。相对于B树，数据只存储在叶子节点，且叶子节点有指针连接（范围查询）
- 哈希索引：通过哈希（crc32等，具体实现不详）生成的索引，平均的取值复杂的为O(1)，极端情况会退化为链表O(n)，性能不稳定
- 全文索引
- 空间数据索引

对比：红黑树 - B+树

- B+树出度大，层高低，红黑树是二叉树，出度为2，所以树非常高
- B+树节点通常设置为磁盘页大小，对磁盘友好（一次IO刚好能读取一页数据，同时磁盘为了减少寻道等时间有预读特性）
- B+树范围查询友好
- B+树索引，MySQL会为高频键生成自适应hash索引

对比：hash - B+树

### 查询性能优化

- 上线前explain sql，熟悉explain结果的字段（查询类型、是否走索引、数据量等，数据量不准确，因为并没有正真执行，只到了SQL优化阶段？）
- 慢查询日志
- sql重构（拆分，避免一次性申请过多锁）

### 切分

    sharding（很多开源方案）

- 水平切分：哈希取模、范围拆分、额外的映射表
- 垂直切分（迁出字段）

### 复制

    有插件支持推到从后提交事务，对于特定领域（如金融）可应用，达到强一致性

- 主从：高可用，主写入binlog，推到从，从写入relaylog，从读取relaylog并重放
- 读写分离：环节锁竞争、从使用MyISAM，提升查询性能
- 高可用：mysql + keepalived