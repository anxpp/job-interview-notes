# Go

## 内存模型

    Go中虽然也分堆和栈，但是实际使用没什么区别。
    也没有直接的向堆申请内存的方法

### 堆和栈

- 堆空间通常比栈大
- 栈存放栈帧，随着函数的调用和返回，系统自动分配和释放，堆内存由程序员（无runtime）或者GC程序管理
- 系统自动处理栈空间，速度更快
- 堆内存分配释放可能造成碎片，需要整理。栈内存时连续的，不会降低程序效率。

### 垃圾回收

常见的GC算法

- 引用计数：每一个对象都有一个关联的引用计数 —— 对该对象的活跃引用的数量。如果对象的引用计数是零，那么它就是垃圾。引用计数不能处理循环应用，所以仅用作解释GC的工作模式
- 标记清理（根搜索算法）：从根变量开始遍历标记所有引用的对象，没有被标记的清理掉，几乎所有GC都使用根搜索算法
- 分代收集：根据对象的特征将内存分成多个区域采用不同的收集策略（如java）

#### Go的三色标记法

    对比java的分代收集，三色法的综合性应该稍差，但是不会浪费内存（复制算法会开辟两块内存）
    新版的go STW整体控制在1ms以内，性能已经比较理想了。

Go中使用三色标记的根搜索法清理垃圾，步骤如下：

- 1、初始状态下所有对象都是白色的
- 2、从根节点开始遍历所有对象，将遍历到的对象置为灰色
- 3、遍历灰色对象，将这些灰色对象置为黑色，并把灰色对象引用的对象置为灰色
- 4、循环3，知道所有灰色对象全部变为黑色
- 5、通过写屏障检测对象变化，重复上面的操作
- 6、收集所有白色对象

根对象从哪里来：

- 全局变量
- goroutine执行栈引用的对象

#### STW（stop the world）

避免GC过程中，对象引用发生变化时造成GC结果错误，需要STW，stp期间会停止所有正在运行的协程

可能的错误：

- 1、GC过程中，有灰色对象的引用被断开，变成root对象实际不可达的节点，这种本应该清理却没被清理
- 2、GC过程中，黑色对象新增了对白色对象的引用，不应该被清理的却清理掉了

对于1，只是造成无用对象的收集延迟，对程序没有太大影响，但是对于2，会造成对象丢失，发生致命错误，这时候就需要写屏障的介入。

#### 写屏障

    写屏障实际是指赋值器的写屏障（赋值器屏障）

对象丢失的条件：

- 条件1：黑色节点A新增了指向了白色节点B的引用
- 条件2：B除了A之外，没有其他灰色节点的引用

以上两点同时满足时，会造成对象丢失，只需要破坏任一条件条件即可

- Dijistra写屏障（强三色不变性）

黑色节点不允许引用白色节点，如果要新增黑色节点对白色节点的引用，将白色节点改为灰色

```go
// 灰色赋值器
func DijkstraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(ptr)  // shade(ptr) 会将尚未变成灰色或黑色的指针 ptr 标记为灰色
    *slot = ptr
}
```

- Yuasa写屏障（弱三色不变性）

黑色节点允许引用白色节点，但是该白色节点有其他灰色节点间接的引用（确保不会被遗漏） 当白色节点被删除了一个引用时，悲观地认为它一定会被一个黑色节点新增引用，所以将它置为灰色

```go
// 黑色赋值器
func YuasaWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(*slot)    // shade(*slot) 会先将 *slot 标记为灰色
    *slot = ptr
}
```

- Go1.8开始使用混合写屏障（结合以上两种）

```go
// 混合写屏障
func HybridWritePointerSimple(slot *unsafe.Pointer, ptr unsafe.Pointer) {
	shade(*slot)
	shade(ptr)
	*slot = ptr
}
```

在 Go 1.8 之前，为了减少写屏障的成本，Go 选择没有启用栈上写操作的写屏障， 赋值器总是可以通过将一个单一的指针移动到某个已经被扫描后的栈， 从而导致某个白色对象被标记为灰色进而隐藏到黑色对象之下，进而需要对栈的重新扫描， 甚至导致栈总是灰色的，因此需要 STW。

混合写屏障为了消除栈的重扫过程，因为一旦栈被扫描变为黑色，则它会继续保持黑色， 并要求将对象分配为黑色。

#### stw发生在什么时候

根据以上分析，会发生在两个阶段：

- 第一次STW会准备根对象的扫描，启动写屏障
- 第二次STW会重新扫描部分根对象, 禁用写屏障

#### 什么时候会出发GC

- 手动 `runtime.GC()`
- 系统定时调用
- 系统根据分配内存时的步调算法

#### 逃逸分析

    Go在编译时，通过逃逸分析确定对象应该在堆上分配还是栈上分配
    栈上无GC，效率优于堆

- 指针逃逸
- 闭包引用逃逸
- 动态类型逃逸
- 栈空间满逃逸

## 协程调度

### GPM模型

### 调度策略

## CSP模型

### chan

## context

## map 与 sync.map